#feature-container.container.mt-5
  .row
    .col-sm-6.col-lg-4
      h1 Interactive PSL
      p You can drag and drop features from left to right and observe how the performance changes
      //p Predict the presence of breast cancer. Which features would be most influencial?
      p Predict whether a student is likely to drop out of university. Which features would be most influencial?
    .col-sm-6.offset-lg-4.col-lg-4
      canvas#chart.loading(height="180px")
  .row.mt-4.loading
    .col-2
      ul#unused.list-group.text-center
        .fw-bold.list-group-item.p-2 Unused
        each fidx, f in var.items
          li.list-group-item.list-group-item-action.p-2.text-truncate.draghandle(data-feature=fidx)= f
            span.material-symbols-outlined.fs-5.btn.btn-sm.p-0.position-absolute.end-0.add.d-none add
    .col-10
      ul#used.list-group.text-center
        .fw-bold.list-group-item.d-flex.p-0
          .cell.col-3.p-2.text-truncate Features
          .cell.col-1.p-2.text-truncate Scores
          for head in headings
            .cell.col.p-2.text-truncate= head
        each row in rows
          li.list-group-item.list-group-item-action.d-flex.p-0(data-feature=row["fidx"] data-threshold=row["thresh"])
            // we could also add additional data into the datafield. such as the threshold
            .cell.label.col.col-3.p-2.text-truncate.draghandle.position-relative= row.fname
                  if row.thresh != ""
                    = row.thresh
                  span.material-symbols-outlined.fs-5.btn.btn-sm.p-0.position-absolute.end-0.remove.d-none close
            .cell.col.col-1.p-2.text-truncate.d-flex.justify-content-around.align-items-center
              span.material-symbols-outlined.fs-5.btn.btn-sm.p-0.decr remove
              = row.score
              span.material-symbols-outlined.fs-5.btn.btn-sm.p-0.incr add
            each val in row.probas
              .cell.col.pt-2.pb-2.text-truncate= val 
  
  .position-fixed.top-50.start-50.spinner-border.d-none
  style.
    .ghost :not(.label){
      display: none !important;
    }
    li:hover .add, li:hover .remove{
      display: inline-block !important;
    }
  script.
    var observer = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutation) {
          mutation.target.querySelectorAll(".cell.label").forEach(elem => {
          if (mutation.target.classList.contains('ghost')) {
            elem.classList.remove("col-3");
          } else {
            elem.classList.add("col-3");
          }
        });
      });
    });

    document.querySelectorAll('li')
      .forEach(elem => {observer.observe(elem, {
        attributes: true,
        attributeFilter: ['class']
      });
    });

    document.querySelectorAll("#unused .add")
      .forEach(e => {
        e.onclick = e => {
          loadStart();          
          htmx.ajax("GET", "/update-table", {
            target: "#feature-container",
            swap: "outerHTML",
            values: {
              type: "feature",
              feature: e.target.closest("li").dataset.feature,
              fromList: "unused",
              toList: "used",
            }
          });
        }
      });
    document.querySelectorAll("#used .remove")
      .forEach(e => {
        e.onclick = e => {
          loadStart();          
          htmx.ajax("GET", "/update-table", {
            target: "#feature-container",
            swap: "outerHTML",
            values: {
              type: "feature",
              feature: e.target.closest("li").dataset.feature,
              fromList: "used",
              toList: "unused",
            }
          });
        }
      });

    document.querySelectorAll("#used .incr")
      .forEach(e => {
        e.onclick = e => {
          loadStart();
          htmx.ajax("GET", "/update-table", {
            target: "#feature-container",
            swap: "outerHTML",
            values: {
              type: "score",
              feature: e.target.closest("li").dataset.feature,
              diff: 1
            }
          });
        }
      });

    document.querySelectorAll("#used .decr")
      .forEach(e => {
        e.onclick = e => {
          loadStart();
          htmx.ajax("GET", "/update-table", {
            target: "#feature-container",
            swap: "outerHTML",
            values: {
              type: "score",
              feature: e.target.closest("li").dataset.feature,
              diff: -1
            }
          });
        }
      });


    document.querySelectorAll("#used .cell:not(:first-child)")
      .forEach(e => e.classList.add("border-start"))
    new Chart(document.querySelector("#chart").getContext('2d'), {
      type: "line",
      data: {
        labels: !{labels},
        datasets: [{
          label: '(Adj.) Balanced Accuracy per stage',
          data: !{metric},
          borderColor: 'rgb(75, 192, 192)' 
        }]
      },
      options: {
        scales: {
          y: {
            beginAtZero: true,
            max: 1.02,   // Set the maximum value of the y-axis
          }
        },
        animation: {
          duration: 0
        },
        responsive: true,
        maintainAspectRatio: false,
      }
    });